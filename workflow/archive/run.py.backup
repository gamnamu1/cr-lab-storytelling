#!/usr/bin/env python3
"""
멀티에이전트 소설 창작 워크플로우
=====================================
5개 에이전트가 협력하여 소설을 창작하는 파이프라인

사용법:
    python run.py --input "소재.txt" --interactive  # 대화형 모드
    python run.py --input "소재.txt" --auto         # 자동 모드
    python run.py --input-text "소재 내용" --auto   # 직접 텍스트 입력
"""

import os
import sys
import argparse
import logging
from datetime import datetime
from pathlib import Path
from typing import Optional
from dataclasses import dataclass, field

try:
    import anthropic
except ImportError:
    print("anthropic 라이브러리가 필요합니다. 설치: pip install anthropic")
    sys.exit(1)


# ============================================================
# 프로젝트 컨텍스트 설정
# ============================================================

PROJECT_CONTEXT_PATH = "project_context.md"
CR_KNOWLEDGE_PATH = "references/cr-knowledge/"


# ============================================================
# 설정
# ============================================================

@dataclass
class Config:
    """워크플로우 설정"""
    agents_dir: Path = field(default_factory=lambda: Path(__file__).parent / "agents")
    outputs_dir: Path = field(default_factory=lambda: Path(__file__).parent / "outputs")
    logs_dir: Path = field(default_factory=lambda: Path(__file__).parent / "logs")
    model: str = "claude-sonnet-4-20250514"
    max_tokens: int = 8192
    max_retries: int = 3

    def __post_init__(self):
        self.outputs_dir.mkdir(parents=True, exist_ok=True)
        self.logs_dir.mkdir(parents=True, exist_ok=True)


# ============================================================
# 에이전트 정의
# ============================================================

@dataclass
class Agent:
    """에이전트 정보"""
    name: str
    file: str
    description: str
    instructions: str = ""


AGENTS = {
    "philosopher": Agent(
        name="철학자",
        file="01-philosopher.md",
        description="소재에서 심오한 화두와 문제의식 도출"
    ),
    "novelist_creator": Agent(
        name="소설가 A",
        file="02-novelist-creator.md",
        description="화두를 담아낼 서사 구조 설계, 시놉시스 및 본문 작성"
    ),
    "novelist_critic": Agent(
        name="소설가 B",
        file="03-novelist-critic.md",
        description="시놉시스의 구조적 완결성 비평 및 건설적 피드백"
    ),
    "editor": Agent(
        name="편집자",
        file="04-editor.md",
        description="문장 다듬기, 가독성 향상, 몰입도 강화"
    ),
    "literary_critic": Agent(
        name="비평가",
        file="05-literary-critic.md",
        description="작품의 문학적 의의와 철학적 해석 제시"
    ),
}


# ============================================================
# 파이프라인 단계 정의
# ============================================================

@dataclass
class PipelineStep:
    """파이프라인 단계"""
    step_num: int
    name: str
    agent_key: str
    output_file: str
    description: str
    is_checkpoint: bool = False


PIPELINE_STEPS = [
    PipelineStep(1, "화두 도출", "philosopher", "01-theme.md",
                 "사용자 소재로부터 철학적 화두와 문제의식 추출"),
    PipelineStep(2, "시놉시스 작성", "novelist_creator", "02-synopsis_v1.md",
                 "화두를 바탕으로 시놉시스 작성"),
    PipelineStep(3, "시놉시스 비평", "novelist_critic", "03-feedback.md",
                 "시놉시스의 구조적 완결성 비평", is_checkpoint=True),
    PipelineStep(4, "본문 초고 작성", "novelist_creator", "04-draft_v1.md",
                 "피드백을 반영하여 본문 초고 작성"),
    PipelineStep(5, "편집 의견", "editor", "05-edit_notes.md",
                 "초고에 대한 편집 의견 제시", is_checkpoint=True),
    PipelineStep(6, "본문 수정", "novelist_creator", "06-draft_v2.md",
                 "편집 의견을 반영하여 본문 수정"),
    PipelineStep(7, "문학적 해석", "literary_critic", "07-critique.md",
                 "작품의 문학적 의의와 승화 방향 제시", is_checkpoint=True),
    PipelineStep(8, "최종본 완성", "novelist_creator", "08-final.md",
                 "비평을 반영하여 최종본 완성"),
]


# ============================================================
# 로거 설정
# ============================================================

def setup_logger(logs_dir: Path) -> logging.Logger:
    """로거 설정"""
    logger = logging.getLogger("novel_workflow")
    logger.setLevel(logging.DEBUG)

    # 파일 핸들러
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = logs_dir / f"session_{timestamp}.log"
    file_handler = logging.FileHandler(log_file, encoding='utf-8')
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(logging.Formatter(
        '%(asctime)s | %(levelname)s | %(message)s'
    ))

    # 콘솔 핸들러
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_handler.setFormatter(logging.Formatter(
        '%(message)s'
    ))

    logger.addHandler(file_handler)
    logger.addHandler(console_handler)

    return logger


# ============================================================
# 워크플로우 클래스
# ============================================================

class NovelWorkflow:
    """멀티에이전트 소설 창작 워크플로우"""

    def __init__(self, config: Optional[Config] = None):
        self.config = config or Config()
        self.logger = setup_logger(self.config.logs_dir)
        self.client = anthropic.Anthropic()
        self.agents = self._load_agents()
        self.context = {}  # 단계별 산출물 저장

    def _load_agents(self) -> dict[str, Agent]:
        """에이전트 지침서 로드"""
        agents = {}
        for key, agent in AGENTS.items():
            agent_file = self.config.agents_dir / agent.file
            if agent_file.exists():
                agent.instructions = agent_file.read_text(encoding='utf-8')
                agents[key] = agent
                self.logger.debug(f"에이전트 로드: {agent.name}")
            else:
                self.logger.warning(f"에이전트 파일 없음: {agent_file}")
        return agents

    def _build_system_prompt(self, agent: Agent) -> str:
        """에이전트 시스템 프롬프트 구성"""
        return f"""당신은 소설 창작 멀티에이전트 시스템의 '{agent.name}' 에이전트입니다.

## 역할
{agent.description}

## 지침서
{agent.instructions}

## 출처 표기 규칙
당신의 판단이나 제안에 참고한 기법이 있다면, 다음 형식으로 근거를 명시하세요: [서적ID: 개념명]

예시:
- [1-1: 3막 구조] — 도입부에서 주인공의 결핍을 명확히 제시하라
- [1-3: Omit needless words] — 불필요한 단어 제거
"""

    def _build_user_prompt(self, step: PipelineStep, user_input: str) -> str:
        """단계별 사용자 프롬프트 구성"""
        prompts = {
            1: f"""## 소재
{user_input}

위 소재를 분석하여 다음을 도출해주세요:
1. 핵심 화두 (이 소재가 던지는 본질적 질문)
2. 문제의식 (탐구해야 할 철학적/인간적 주제)
3. 가능한 갈등 구조
4. 독자에게 전달할 통찰

명확하고 구체적으로 작성하며, 소설가 에이전트가 이를 바탕으로 서사를 구축할 수 있도록 해주세요.""",

            2: f"""## 철학자가 도출한 화두
{self.context.get('theme', '')}

위 화두를 바탕으로 단편소설 시놉시스를 작성해주세요:
1. 시공간 설정
2. 주요 등장인물 (성격, 동기, 갈등)
3. 플롯 구조 (발단-전개-위기-절정-결말)
4. 핵심 장면 3-5개
5. 예상되는 주제 전달 방식

한국어로 작성하며, 감각적이고 몰입감 있는 서사가 되도록 설계해주세요.""",

            3: f"""## 시놉시스
{self.context.get('synopsis_v1', '')}

위 시놉시스를 구조적 관점에서 비평해주세요:
1. 잘된 점 (구체적으로)
2. 개선이 필요한 점 (구체적으로)
3. 서사적 긴장과 갈등의 충분성
4. 인물 동기의 설득력
5. 주제와 플롯의 유기적 연결
6. 구체적인 수정 제안

건설적이고 실행 가능한 피드백을 제공해주세요.""",

            4: f"""## 시놉시스
{self.context.get('synopsis_v1', '')}

## 소설가 B의 피드백
{self.context.get('feedback', '')}

위 시놉시스와 피드백을 바탕으로 단편소설 본문을 작성해주세요.

요구사항:
- 분량: 3,000-5,000자 내외
- 감각적이고 생생한 묘사
- 자연스러운 대화문
- 긴장감 있는 전개
- 철학자가 도출한 화두가 자연스럽게 녹아들도록

소설 본문만 작성해주세요 (메타 설명 제외).""",

            5: f"""## 본문 초고
{self.context.get('draft_v1', '')}

위 초고를 편집 관점에서 분석해주세요:
1. 문장 수준의 개선점 (구체적 예시와 함께)
2. 리듬과 호흡의 문제점
3. 불필요한 표현이나 군더더기
4. 시점과 톤의 일관성
5. 대화문의 자연스러움
6. 구체적인 수정 제안 (원문 → 수정안 형식)

실행 가능한 수정 지침을 제공해주세요.""",

            6: f"""## 본문 초고
{self.context.get('draft_v1', '')}

## 편집자 의견
{self.context.get('edit_notes', '')}

편집자의 의견을 반영하여 본문을 수정해주세요.

수정 시 주의사항:
- 문장의 간결성과 명료성 향상
- 리듬과 호흡 개선
- 불필요한 표현 제거
- 감각적 표현 강화

수정된 소설 본문만 작성해주세요.""",

            7: f"""## 수정된 본문
{self.context.get('draft_v2', '')}

위 작품을 문학적 관점에서 비평해주세요:
1. 주제의식 분석
2. 상징과 모티프 해독
3. 서사 전략의 효과 (시점, 화자, 거리)
4. 작품의 문학적 의의
5. '재미있는 이야기'에서 '통찰이 담긴 문학'으로 승화시키기 위한 제안
6. 독자 반응 예측

작가에게 도움이 되는 깊이 있는 비평을 제공해주세요.""",

            8: f"""## 수정된 본문
{self.context.get('draft_v2', '')}

## 비평가 해석
{self.context.get('critique', '')}

비평가의 해석과 제안을 반영하여 최종본을 완성해주세요.

최종본 요구사항:
- 주제의식이 더 명확하게 드러나도록
- 상징과 모티프가 효과적으로 작동하도록
- 문학적 깊이가 더해지도록
- 독자에게 여운을 남기는 결말

완성된 소설 본문만 작성해주세요.""",
        }
        return prompts.get(step.step_num, user_input)

    def run_agent(self, agent_key: str, user_prompt: str) -> str:
        """특정 에이전트로서 작업 수행"""
        agent = self.agents.get(agent_key)
        if not agent:
            raise ValueError(f"에이전트를 찾을 수 없습니다: {agent_key}")

        system_prompt = self._build_system_prompt(agent)

        for attempt in range(self.config.max_retries):
            try:
                self.logger.debug(f"API 호출: {agent.name} (시도 {attempt + 1})")

                response = self.client.messages.create(
                    model=self.config.model,
                    max_tokens=self.config.max_tokens,
                    system=system_prompt,
                    messages=[{"role": "user", "content": user_prompt}]
                )

                result = response.content[0].text
                self.logger.debug(f"응답 수신: {len(result)} 자")
                return result

            except anthropic.APIError as e:
                self.logger.error(f"API 오류 (시도 {attempt + 1}): {e}")
                if attempt == self.config.max_retries - 1:
                    raise

        return ""

    def save_output(self, step: PipelineStep, content: str) -> Path:
        """산출물 저장"""
        output_file = self.config.outputs_dir / step.output_file
        output_file.write_text(content, encoding='utf-8')
        self.logger.info(f"  → 저장: {output_file.name}")
        return output_file

    def get_user_decision(self, step: PipelineStep) -> str:
        """체크포인트에서 사용자 결정 받기"""
        print("\n" + "=" * 60)
        print(f"[체크포인트] Step {step.step_num} 완료: {step.name}")
        print("=" * 60)
        print("\n선택해주세요:")
        print("  1. 진행 (다음 단계로)")
        print("  2. 수정 (이전 단계 재실행)")
        print("  3. 중단 (현재까지 저장 후 종료)")
        print()

        while True:
            choice = input("선택 (1/2/3): ").strip()
            if choice in ['1', '2', '3']:
                return {'1': 'proceed', '2': 'revise', '3': 'stop'}[choice]
            print("1, 2, 3 중 하나를 입력해주세요.")

    def run_step(self, step: PipelineStep, user_input: str) -> str:
        """단일 단계 실행"""
        self.logger.info(f"\n{'='*60}")
        self.logger.info(f"Step {step.step_num}: {step.name}")
        self.logger.info(f"에이전트: {AGENTS[step.agent_key].name}")
        self.logger.info(f"{'='*60}")

        user_prompt = self._build_user_prompt(step, user_input)
        result = self.run_agent(step.agent_key, user_prompt)
        self.save_output(step, result)

        return result

    def run_pipeline(self, user_input: str, interactive: bool = True) -> dict:
        """전체 파이프라인 실행"""
        self.logger.info("\n" + "=" * 60)
        self.logger.info("멀티에이전트 소설 창작 파이프라인 시작")
        self.logger.info(f"모드: {'대화형' if interactive else '자동'}")
        self.logger.info("=" * 60)

        # 컨텍스트 매핑
        context_keys = {
            1: 'theme',
            2: 'synopsis_v1',
            3: 'feedback',
            4: 'draft_v1',
            5: 'edit_notes',
            6: 'draft_v2',
            7: 'critique',
            8: 'final',
        }

        current_step_idx = 0

        while current_step_idx < len(PIPELINE_STEPS):
            step = PIPELINE_STEPS[current_step_idx]

            try:
                result = self.run_step(step, user_input)
                self.context[context_keys[step.step_num]] = result

                # 체크포인트 처리
                if interactive and step.is_checkpoint:
                    decision = self.get_user_decision(step)

                    if decision == 'stop':
                        self.logger.info("\n파이프라인 중단됨")
                        break
                    elif decision == 'revise':
                        # 이전 단계로 회귀 (간단히 2단계 전으로)
                        current_step_idx = max(0, current_step_idx - 2)
                        self.logger.info(f"\nStep {PIPELINE_STEPS[current_step_idx].step_num}부터 재실행")
                        continue

                current_step_idx += 1

            except Exception as e:
                self.logger.error(f"오류 발생: {e}")
                if interactive:
                    retry = input("재시도할까요? (y/n): ").strip().lower()
                    if retry != 'y':
                        break
                else:
                    raise

        self.logger.info("\n" + "=" * 60)
        self.logger.info("파이프라인 완료")
        self.logger.info(f"산출물 위치: {self.config.outputs_dir}")
        self.logger.info("=" * 60)

        return self.context


# ============================================================
# 확장 기능: 도메인 학습 및 재작성 모드
# ============================================================

# 추가 에이전트 정의
EXTENDED_AGENTS = {
    "researcher": Agent(
        name="리서처",
        file="00-researcher.md",
        description="도메인 페르소나 기반 전문 지식 제공"
    ),
    "diagnostician": Agent(
        name="진단자",
        file="00-diagnostician.md",
        description="피드백 분석, 수정 범위/방향 결정"
    ),
}


# ============================================
# 도메인 페르소나 설정
# ============================================

DOMAIN_PERSONA_TEMPLATE = """
당신은 {experience}년 경력의 {role}입니다.

경험:
{experiences}

## 중요: 관점 중립성 원칙

당신은 **지식 제공자**이지, 옹호자나 비판자가 아닙니다.

1. 내부자로서의 경험과 지식을 제공하되, 특정 입장을 옹호하지 마세요
2. "이런 시각이 있고, 저런 시각도 있다"는 식으로 병렬 제시하세요
3. 체제 내부 논리와 비판자 논리를 모두 설명하세요
4. 가치 판단은 소설가에게 맡기고, 당신은 재료만 제공하세요
5. 내부자로서의 편향 가능성을 인식하고, "외부에서는 다르게 볼 수 있다"고 명시하세요

## 제공해야 할 내용

1. **이 세계의 실제 작동 방식** (공식 vs 실제)

2. **이 세계의 사람들** (인물 유형 5가지 이상, 각각의 동기와 갈등)

3. **드라마의 씨앗들** (딜레마, 갈등, 전환점)

4. **감각적 디테일** (공간, 소리, 시간, 언어)

5. **클리셰 vs 현실** (대중의 오해, 피해야 할 진부함)

6. **다중 관점 지도** (반드시 포함)
   - 체제 내부자의 논리: 시스템이 유지되는 이유, 내부자의 정당화
   - 체제 비판자의 논리: 구조적 문제점, 변화 요구의 근거
   - 중간 지대: 이상과 현실 사이의 타협, 체제 내 개혁 시도
   - 외부자/피해자의 시선: 밖에서 보이는 모습, 신뢰가 무너진 이유
"""

DOMAIN_PERSONAS = {
    "언론/탐사보도": {
        "experience": 20,
        "role": "탐사보도 기자",
        "experiences": """- 대형 언론사와 독립 매체 모두에서 일한 경험
- 권력 비리를 파헤쳐 상을 받기도, 기사가 묻히기도 한 경험
- 취재원 보호로 법적 압박과 회유를 받아본 경험
- 편집국 내부의 정치, 광고주 압력, 자기검열을 목격한 경험
- 특종의 희열과 오보의 트라우마를 모두 겪은 경험"""
    },
    "언론/방송뉴스": {
        "experience": 18,
        "role": "방송뉴스 기자 겸 앵커",
        "experiences": """- 지상파와 종편, 보도전문채널을 모두 경험
- 생방송 사고와 특종 보도의 긴장감을 체험한 경험
- 시청률 압박과 저널리즘 사이에서 고민한 경험
- 카메라 앞과 뒤의 전혀 다른 세계를 경험
- 정치권, 재계와의 복잡한 관계를 경험"""
    },
    "의료/응급의학": {
        "experience": 15,
        "role": "응급의학과 전문의",
        "experiences": """- 대학병원 권역응급센터와 지방 병원 응급실 모두 경험
- 생사의 갈림길에서 초 단위 판단을 내려온 경험
- 의료 시스템의 한계 앞에서 무력감을 느낀 경험
- 환자의 죽음, 보호자의 분노, 의료 소송을 겪은 경험
- 번아웃 직전까지 갔다가 다시 일어선 경험"""
    },
    "의료/외과": {
        "experience": 20,
        "role": "외과 전문의",
        "experiences": """- 대학병원 교수와 개원의 경험 모두 보유
- 수술 중 예상치 못한 상황에서 판단을 내린 경험
- 환자 가족에게 나쁜 소식을 전해야 했던 경험
- 후배 의사 교육과 의료 사고 수습을 겪은 경험
- 의사로서의 권위와 인간적 한계 사이의 갈등"""
    },
    "법조/형사변호": {
        "experience": 18,
        "role": "형사전문 변호사",
        "experiences": """- 대형 로펌과 개인 사무실 모두 운영해본 경험
- 무고한 피고인을 구하기도, 유죄인 줄 알면서 변호하기도 한 경험
- 검찰, 판사, 경찰과의 복잡한 관계를 경험
- 의뢰인의 거짓말에 배신당한 경험
- 정의와 직업윤리 사이의 딜레마를 겪은 경험"""
    },
    "법조/검찰": {
        "experience": 17,
        "role": "검사",
        "experiences": """- 지방청과 대검, 특수부를 모두 경험
- 정치적 압력과 수사 독립 사이에서 고민한 경험
- 기소와 불기소 결정의 무게를 체감한 경험
- 피의자의 억울함과 피해자의 분노 사이에 선 경험
- 승진과 소신 사이의 갈등을 겪은 경험"""
    },
    "교육/고등학교": {
        "experience": 22,
        "role": "고등학교 교사",
        "experiences": """- 명문고와 일반고, 특성화고를 모두 경험
- 입시 압박과 교육적 이상 사이에서 갈등한 경험
- 학생의 성장을 목격한 보람과 한계의 좌절 경험
- 학부모, 관리자, 동료와의 복잡한 관계
- 교권 침해와 학생 인권 사이의 줄타기 경험"""
    },
    "기업/스타트업": {
        "experience": 12,
        "role": "스타트업 창업자 겸 CTO",
        "experiences": """- 성공적 엑싯과 실패한 창업을 모두 경험
- 투자 유치의 희열과 런웨이 압박의 공포를 경험
- 공동창업자와의 갈등과 결별을 경험
- 직원 해고와 피봇의 고통을 겪은 경험
- 이상과 현금흐름 사이의 현실을 체감"""
    },
}


class ExtendedNovelWorkflow(NovelWorkflow):
    """확장된 멀티에이전트 소설 창작 워크플로우 (도메인 학습 + 재작성 모드)"""

    def __init__(self, config: Optional[Config] = None):
        super().__init__(config)
        self._load_extended_agents()
        self.project_context = self._load_project_context()

    def _load_project_context(self) -> str:
        """프로젝트 컨텍스트 로드"""
        context_file = self.config.agents_dir.parent / PROJECT_CONTEXT_PATH
        if context_file.exists():
            self.logger.debug(f"프로젝트 컨텍스트 로드: {context_file}")
            return context_file.read_text(encoding='utf-8')
        return ""

    def _load_cr_knowledge(self, filename: str) -> str:
        """개별 CR 지식 파일 로드"""
        knowledge_dir = self.config.agents_dir.parent / CR_KNOWLEDGE_PATH
        knowledge_file = knowledge_dir / filename
        if knowledge_file.exists():
            self.logger.debug(f"CR 지식 로드: {filename}")
            return knowledge_file.read_text(encoding='utf-8')
        return ""

    def _load_all_cr_knowledge(self) -> str:
        """모든 CR 지식 파일 로드 (언론 도메인용)"""
        knowledge_dir = self.config.agents_dir.parent / CR_KNOWLEDGE_PATH
        if not knowledge_dir.exists():
            return ""

        materials = []
        for filepath in sorted(knowledge_dir.glob("*.md")):
            content = filepath.read_text(encoding='utf-8')
            materials.append(f"### {filepath.stem}\n{content}")
            self.logger.debug(f"CR 지식 로드: {filepath.name}")

        if materials:
            self.logger.info(f"CR 지식 베이스 {len(materials)}개 파일 로드됨")
        return "\n\n---\n\n".join(materials)

    def _build_system_prompt(self, agent: Agent) -> str:
        """에이전트 시스템 프롬프트 구성 (프로젝트 컨텍스트 포함)"""
        base_prompt = super()._build_system_prompt(agent)

        if self.project_context:
            return f"""{base_prompt}

## 프로젝트 컨텍스트 (필독)
{self.project_context}
"""
        return base_prompt

    def _load_extended_agents(self):
        """확장 에이전트 지침서 로드"""
        for key, agent in EXTENDED_AGENTS.items():
            agent_file = self.config.agents_dir / agent.file
            if agent_file.exists():
                agent.instructions = agent_file.read_text(encoding='utf-8')
                self.agents[key] = agent
                self.logger.debug(f"확장 에이전트 로드: {agent.name}")

    def generate_persona_prompt(self, domain: str) -> str:
        """도메인 키워드로 페르소나 프롬프트 생성"""
        if domain in DOMAIN_PERSONAS:
            persona = DOMAIN_PERSONAS[domain]
            return DOMAIN_PERSONA_TEMPLATE.format(**persona)
        else:
            # 미등록 도메인: 일반 템플릿
            return f"""
당신은 '{domain}' 분야에서 15-20년간 일해온 베테랑입니다.

## 중요: 관점 중립성 원칙

당신은 **지식 제공자**이지, 옹호자나 비판자가 아닙니다.

1. 내부자로서의 경험과 지식을 제공하되, 특정 입장을 옹호하지 마세요
2. "이런 시각이 있고, 저런 시각도 있다"는 식으로 병렬 제시하세요
3. 체제 내부 논리와 비판자 논리를 모두 설명하세요
4. 가치 판단은 소설가에게 맡기고, 당신은 재료만 제공하세요

## 제공해야 할 내용

1. **이 세계의 실제 작동 방식** (공식 vs 실제)
2. **이 세계의 사람들** (인물 유형 5가지 이상)
3. **드라마의 씨앗들** (딜레마, 갈등, 전환점)
4. **감각적 디테일** (공간, 소리, 시간, 언어)
5. **클리셰 vs 현실**
6. **다중 관점 지도**
   - 체제 내부자의 논리
   - 체제 비판자의 논리
   - 중간 지대
   - 외부자/피해자의 시선
"""

    def load_domain_materials(self, domain_path: str) -> str:
        """(선택적) 추가 자료 로드"""
        if not domain_path:
            return ""

        from pathlib import Path
        domain_dir = Path(domain_path)

        if not domain_dir.exists():
            return ""

        materials = []
        for filepath in sorted(domain_dir.glob("*.md")):
            content = filepath.read_text(encoding='utf-8')
            materials.append(f"### {filepath.name}\n{content}")
            self.logger.debug(f"추가 자료 로드: {filepath.name}")

        if materials:
            self.logger.info(f"추가 자료 {len(materials)}개 로드됨")
        return "\n\n".join(materials)

    def run_researcher(self, user_input: str, domain: str, domain_refs: str = None) -> str:
        """리서처 에이전트: 페르소나 기반 도메인 지식 생성"""
        self.logger.info("\n" + "=" * 60)
        self.logger.info("Step 0: 도메인 지식 추출")
        self.logger.info(f"도메인: {domain}")
        self.logger.info("에이전트: 리서처")
        self.logger.info("=" * 60)

        # 페르소나 프롬프트 생성
        persona_prompt = self.generate_persona_prompt(domain)

        # (선택적) 추가 자료 로드
        ref_materials = ""
        if domain_refs:
            loaded = self.load_domain_materials(domain_refs)
            if loaded:
                ref_materials = f"\n\n## 추가 참고 자료 (보강용)\n{loaded}"

        # 언론 도메인인 경우 CR 지식 베이스 자동 로드
        cr_knowledge = ""
        if "언론" in domain:
            cr_knowledge_content = self._load_all_cr_knowledge()
            if cr_knowledge_content:
                cr_knowledge = f"\n\n## CR 지식 베이스 (언론 문제 이해용)\n{cr_knowledge_content}"
                self.logger.info("언론 도메인 감지: CR 지식 베이스 자동 로드됨")

        # 컨텍스트 구성
        full_prompt = f"""
{persona_prompt}

## 소설 소재
{user_input}
{ref_materials}
{cr_knowledge}
"""

        result = self.run_agent("researcher", full_prompt)
        output_file = self.config.outputs_dir / "00-domain_knowledge.md"
        output_file.write_text(result, encoding='utf-8')
        self.logger.info(f"  → 저장: {output_file.name}")

        return result

    def run_diagnostician(self, final_text: str, feedback: str) -> str:
        """진단자 에이전트: 피드백 분석 및 수정 계획"""
        self.logger.info("\n" + "=" * 60)
        self.logger.info("Step R1: 피드백 분석")
        self.logger.info("에이전트: 진단자")
        self.logger.info("=" * 60)

        prompt = f"""## 기존 완성본
{final_text}

## 독자 피드백
{feedback}

위 피드백을 분석하여 수정 계획을 수립해주세요.
지침서의 출력 템플릿(revision_plan.md 구조)을 따라 작성해주세요.
"""

        result = self.run_agent("diagnostician", prompt)
        output_file = self.config.outputs_dir / "R1-revision_plan.md"
        output_file.write_text(result, encoding='utf-8')
        self.logger.info(f"  → 저장: {output_file.name}")

        return result

    def run_pipeline_with_domain(self, user_input: str, domain: str,
                                   domain_refs: str = None, interactive: bool = True):
        """도메인 학습 모드 파이프라인"""
        self.logger.info("\n" + "=" * 60)
        self.logger.info("멀티에이전트 소설 창작 파이프라인 시작")
        self.logger.info("모드: 도메인 학습 (페르소나 기반)")
        self.logger.info(f"도메인: {domain}")
        if domain_refs:
            self.logger.info(f"추가 자료: {domain_refs}")
        self.logger.info("=" * 60)

        # Step 0: 리서처 (페르소나 기반)
        domain_knowledge = self.run_researcher(user_input, domain, domain_refs)
        self.context['domain_knowledge'] = domain_knowledge

        # Step 1 이후: 도메인 지식을 포함한 입력으로 기존 파이프라인 실행
        enhanced_input = f"""{user_input}

---

## 참고: 도메인 지식 (리서처 분석 결과)

{domain_knowledge}
"""

        # 기존 파이프라인 실행
        return self.run_pipeline(enhanced_input, interactive=interactive)

    def run_revision(self, final_path: str, feedback: str, interactive: bool = True):
        """재작성 모드 파이프라인"""
        self.logger.info("\n" + "=" * 60)
        self.logger.info("멀티에이전트 소설 재작성 파이프라인 시작")
        self.logger.info("모드: 재작성")
        self.logger.info("=" * 60)

        # 기존 완성본 로드
        final_file = Path(final_path)
        if not final_file.exists():
            self.logger.error(f"완성본 파일을 찾을 수 없습니다: {final_path}")
            return None

        final_text = final_file.read_text(encoding='utf-8')
        self.logger.info(f"기존 완성본 로드: {final_path}")

        # Step R1: 진단자
        revision_plan = self.run_diagnostician(final_text, feedback)
        self.context['revision_plan'] = revision_plan

        # Step R2: 소설가 A가 수정 계획 반영
        self.logger.info("\n" + "=" * 60)
        self.logger.info("Step R2: 본문 수정")
        self.logger.info("에이전트: 소설가 A")
        self.logger.info("=" * 60)

        revision_prompt = f"""## 기존 완성본
{final_text}

## 수정 계획
{revision_plan}

위 수정 계획에 따라 소설을 수정해주세요.
- 수정 계획의 우선순위를 따르세요.
- 보존해야 할 강점은 유지하세요.
- 수정된 소설 본문만 출력하세요.
"""

        revised = self.run_agent("novelist_creator", revision_prompt)
        output_file = self.config.outputs_dir / "R2-draft_revised.md"
        output_file.write_text(revised, encoding='utf-8')
        self.logger.info(f"  → 저장: {output_file.name}")

        # Step R3: 편집자 검토
        self.logger.info("\n" + "=" * 60)
        self.logger.info("Step R3: 수정본 검토")
        self.logger.info("에이전트: 편집자")
        self.logger.info("=" * 60)

        edit_prompt = f"""## 수정된 본문
{revised}

## 원래 피드백
{feedback}

위 수정본을 검토하고 편집 의견을 제시해주세요.
- 피드백이 적절히 반영되었는지 확인
- 추가 개선점이 있다면 제안
"""

        edit_notes = self.run_agent("editor", edit_prompt)
        output_file = self.config.outputs_dir / "R3-edit_notes.md"
        output_file.write_text(edit_notes, encoding='utf-8')
        self.logger.info(f"  → 저장: {output_file.name}")

        # 체크포인트
        if interactive:
            print("\n" + "=" * 60)
            print("[체크포인트] 수정본 검토 완료")
            print("=" * 60)
            print("\n1. 진행 (최종 반영)")
            print("2. 중단 (현재까지 저장)")
            choice = input("\n선택 (1/2): ").strip()
            if choice == '2':
                self.logger.info("재작성 중단됨")
                return revised

        # Step R4: 최종 반영
        self.logger.info("\n" + "=" * 60)
        self.logger.info("Step R4: 최종 반영")
        self.logger.info("에이전트: 소설가 A")
        self.logger.info("=" * 60)

        final_prompt = f"""## 수정된 본문
{revised}

## 편집자 의견
{edit_notes}

편집자의 의견을 반영하여 최종본을 완성해주세요.
수정된 소설 본문만 출력하세요.
"""

        revised_final = self.run_agent("novelist_creator", final_prompt)
        output_file = self.config.outputs_dir / "revised_final.md"
        output_file.write_text(revised_final, encoding='utf-8')
        self.logger.info(f"  → 저장: {output_file.name}")

        self.logger.info("\n" + "=" * 60)
        self.logger.info("재작성 완료")
        self.logger.info(f"최종본: {output_file}")
        self.logger.info("=" * 60)

        return revised_final


# ============================================================
# 메인 실행
# ============================================================

def main():
    parser = argparse.ArgumentParser(
        description="멀티에이전트 소설 창작 워크플로우",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
사용 예시:
  # 기본 모드
  python run.py --input 소재.txt --interactive    # 대화형 모드
  python run.py --input 소재.txt --auto           # 자동 모드
  python run.py --input-text "소재 내용" --auto   # 직접 텍스트 입력

  # 도메인 학습 모드 (페르소나 기반)
  python run.py --input 소재.txt --domain "언론/탐사보도" --auto

  # 도메인 학습 모드 + 추가 자료
  python run.py --input 소재.txt --domain "언론/탐사보도" --domain-refs references/journalism/ --auto

  # 재작성 모드
  python run.py --revise outputs/08-final.md --feedback "결말이 급해요" --auto
  python run.py --revise outputs/08-final.md --feedback-file feedback.txt --auto
        """
    )

    # 기본 입력 (재작성 모드가 아닐 때)
    input_group = parser.add_mutually_exclusive_group()
    input_group.add_argument('--input', '-i', type=str, help='입력 파일 경로')
    input_group.add_argument('--input-text', '-t', type=str, help='직접 텍스트 입력')

    # 실행 모드
    mode_group = parser.add_mutually_exclusive_group()
    mode_group.add_argument('--interactive', action='store_true', help='대화형 모드')
    mode_group.add_argument('--auto', action='store_true', help='자동 모드')

    # 도메인 학습 모드
    parser.add_argument('--domain', type=str,
                       help='도메인 키워드 (예: "언론/탐사보도", "의료/응급의학")')
    parser.add_argument('--domain-refs', type=str,
                       help='(선택) 추가 참고 자료 디렉토리 경로')

    # 재작성 모드
    parser.add_argument('--revise', type=str, help='재작성할 기존 완성본 경로')
    parser.add_argument('--feedback', type=str, help='독자 피드백 (직접 입력)')
    parser.add_argument('--feedback-file', type=str, help='독자 피드백 파일 경로')

    # 공통 옵션
    parser.add_argument('--model', type=str, default="claude-sonnet-4-20250514",
                       help='사용할 모델 (기본: claude-sonnet-4-20250514)')

    args = parser.parse_args()

    # 설정
    config = Config(model=args.model)

    # 모드 판단
    if args.revise:
        # 재작성 모드
        if not args.feedback and not args.feedback_file:
            print("오류: 재작성 모드에서는 --feedback 또는 --feedback-file이 필요합니다.")
            sys.exit(1)

        feedback = args.feedback
        if args.feedback_file:
            feedback_path = Path(args.feedback_file)
            if not feedback_path.exists():
                print(f"오류: 피드백 파일을 찾을 수 없습니다: {feedback_path}")
                sys.exit(1)
            feedback = feedback_path.read_text(encoding='utf-8')

        interactive = args.interactive if (args.interactive or args.auto) else False

        workflow = ExtendedNovelWorkflow(config)
        workflow.run_revision(args.revise, feedback, interactive=interactive)

    elif args.input or args.input_text:
        # 기본 또는 도메인 학습 모드
        if not args.interactive and not args.auto:
            print("오류: --interactive 또는 --auto 모드를 선택해주세요.")
            sys.exit(1)

        # 입력 텍스트 로드
        if args.input:
            input_path = Path(args.input)
            if not input_path.exists():
                print(f"오류: 파일을 찾을 수 없습니다: {input_path}")
                sys.exit(1)
            user_input = input_path.read_text(encoding='utf-8')
        else:
            user_input = args.input_text

        if args.domain:
            # 도메인 학습 모드 (페르소나 기반)
            workflow = ExtendedNovelWorkflow(config)
            domain_refs = getattr(args, 'domain_refs', None)
            workflow.run_pipeline_with_domain(
                user_input, args.domain,
                domain_refs=domain_refs,
                interactive=args.interactive
            )
        else:
            # 기본 모드
            workflow = NovelWorkflow(config)
            workflow.run_pipeline(user_input, interactive=args.interactive)

    else:
        parser.print_help()
        sys.exit(1)


if __name__ == "__main__":
    main()
