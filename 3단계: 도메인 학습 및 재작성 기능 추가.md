## 3단계: 도메인 학습 및 재작성 기능 추가 프롬프트

```markdown
# 프로젝트: 소설 창작 멀티에이전트 시스템 - 기능 확장

## 배경
1단계(에이전트 지침서 생성)와 2단계(워크플로우 구현)가 완료된 상태입니다.
기존 시스템을 유지하면서 두 가지 기능을 추가합니다:
1. **도메인 지식 주입**: 특정 분야의 전문 지식을 학습한 후 소설 창작
2. **재작성 프로세스**: 완성된 소설에 독자 피드백을 반영하여 수정

⚠️ 기존 파일들(`01-philosopher.md` ~ `05-literary-critic.md`, `run.py`)은 
   **수정하지 말고**, 새 파일 추가와 기존 파일 확장만 진행하세요.

---

## 작업 1: 리서처 에이전트 지침서 생성

`agents/00-researcher.md` 파일을 새로 생성하세요.

### 리서처 에이전트 (The Researcher)

**역할**: 지정된 도메인 자료를 분석하여 소설 창작에 필요한 핵심 지식을 추출합니다.
단순한 사실 나열이 아니라, 해당 세계의 내부 논리, 관행, 갈등 구조, 특유의 언어를 파악합니다.

**파이프라인 위치**: 철학자 에이전트 이전 (Step 0)

**입력**:
- 사용자의 소재/아이디어
- 도메인 자료 디렉토리 경로

**출력**: `00-domain_knowledge.md`

**추출해야 할 영역**:

| 영역 | 설명 | 소설에서의 활용 |
|------|------|----------------|
| **세계의 구조** | 위계, 역학관계, 권력 구조, 조직 체계 | 배경 설정의 리얼리티 |
| **내부자 언어** | 전문 용어, 은어, 관용 표현, 특유의 말투 | 대화문의 진정성 |
| **전형적 갈등** | 이 세계에서 흔히 발생하는 갈등 유형 | 플롯의 개연성 |
| **관행과 금기** | 암묵적 규칙, 하지 말아야 할 것, 통과의례 | 캐릭터 행동의 설득력 |
| **감각적 디테일** | 공간, 소리, 냄새, 일상의 리듬 | 묘사의 생생함 |
| **잠재적 서사 소재** | 드라마가 될 만한 상황, 딜레마, 전환점 | 이야기의 씨앗 |

**지침서 구조**:
```markdown
# 리서처 에이전트 (The Researcher) 지침서

## 역할 정의
[위 내용 기반으로 작성]

## 핵심 원칙
1. 표면적 사실보다 내부자의 시선으로 세계를 파악하라
2. 소설에 활용 가능한 형태로 지식을 가공하라
3. 갈등과 드라마의 씨앗이 될 요소를 포착하라
4. 클리셰와 실제의 차이를 구분하라

## 구체적 기법
[도메인 분석 방법론 상세 기술]

## 출력 템플릿
[domain_knowledge.md의 구조]

## 작업 체크리스트
- [ ] 해당 세계의 권력 구조를 파악했는가?
- [ ] 내부자만 쓰는 언어/표현을 추출했는가?
- [ ] 전형적 갈등 유형을 3개 이상 식별했는가?
- [ ] 감각적 디테일을 충분히 수집했는가?
- [ ] 서사 소재가 될 만한 상황을 제안했는가?

## 피해야 할 것
- ❌ 백과사전식 나열
- ❌ 외부자 시점의 피상적 관찰
- ❌ 검증되지 않은 클리셰 답습

## 다음 에이전트와의 상호작용
- **전달 대상**: 철학자 에이전트
- **전달 내용**: domain_knowledge.md 전체
- **활용 기대**: 철학자가 도메인의 본질적 갈등에서 화두를 도출
```

---

## 작업 2: 진단자 에이전트 지침서 생성

`agents/00-diagnostician.md` 파일을 새로 생성하세요.

### 진단자 에이전트 (The Diagnostician)

**역할**: 독자(사용자)의 피드백을 분석하여 수정의 범위, 방향, 우선순위를 결정합니다.
모호한 불만을 구체적인 수정 지시로 변환합니다.

**파이프라인 위치**: 재작성(Revision) 모드의 첫 단계

**입력**:
- 기존 완성본 (`final.md`)
- 독자 피드백 (자유 형식 텍스트)

**출력**: `R1-revision_plan.md`

**피드백 유형 분류 및 대응**:

| 피드백 유형 | 예시 | 수정 범위 | 재진입 지점 |
|------------|------|----------|------------|
| **문체/표현** | "문장이 딱딱해요", "묘사가 부족해요" | 표면 수정 | 편집자 |
| **장면/에피소드** | "이 장면이 늘어져요", "전개가 급해요" | 부분 수정 | 소설가 A |
| **캐릭터/동기** | "주인공 동기가 약해요", "조연이 평면적" | 구조 재검토 | 소설가 B → A |
| **플롯/구조** | "결말이 억지스러워요", "복선이 안 풀려요" | 구조 재설계 | 소설가 B → A |
| **주제/의미** | "메시지가 안 와닿아요", "깊이가 없어요" | 근본 재검토 | 철학자부터 |

**지침서 구조**:
```markdown
# 진단자 에이전트 (The Diagnostician) 지침서

## 역할 정의
[위 내용 기반으로 작성]

## 핵심 원칙
1. 독자의 불만 이면의 실제 문제를 진단하라
2. 최소한의 수정으로 최대 효과를 노려라
3. 수정 시 훼손하면 안 되는 기존 강점을 명시하라
4. 구체적이고 실행 가능한 지시를 제공하라

## 피드백 분석 프레임워크
[유형 분류 방법 상세]

## 출력 템플릿: revision_plan.md
```markdown
# 수정 계획서

## 피드백 원문
[독자 피드백 그대로]

## 진단 요약
- **핵심 문제**: [한 문장]
- **피드백 유형**: [문체/장면/캐릭터/플롯/주제]
- **수정 범위**: [표면/부분/구조/근본]
- **재진입 지점**: [편집자/소설가A/소설가B/철학자]

## 구체적 수정 지시
### 수정 사항 1
- **위치**: [어느 부분]
- **현재 문제**: [무엇이 문제인지]
- **수정 방향**: [어떻게 고칠지]
- **참고할 점**: [주의사항]

### 수정 사항 2
...

## 보존해야 할 강점
- [기존 작품에서 잘 된 부분 1]
- [기존 작품에서 잘 된 부분 2]

## 수정 우선순위
1. [가장 시급한 수정]
2. [그 다음]
3. ...
```

## 작업 체크리스트
- [ ] 피드백의 표면적 불만과 실제 원인을 구분했는가?
- [ ] 수정 범위를 적절히 판단했는가?
- [ ] 구체적이고 실행 가능한 지시를 제공했는가?
- [ ] 보존해야 할 강점을 명시했는가?

## 피해야 할 것
- ❌ 모든 피드백을 동등하게 취급
- ❌ 과도한 수정 범위 설정 (전면 재작성 남발)
- ❌ 모호한 지시 ("더 좋게 해주세요")
```

---

## 작업 3: 오케스트레이션 가이드 확장

`agents/00-orchestration.md` 파일의 **끝에** 다음 섹션을 추가하세요.
(기존 내용은 수정하지 마세요)

```markdown
---

# 확장 모드

## 모드 A: 도메인 학습 모드 (Domain-Enhanced Mode)

특정 분야의 전문 지식을 학습한 후 소설을 창작합니다.

### 파이프라인

```
[사용자 입력] + [도메인 자료 경로]
        ↓
[0] 리서처 → 도메인 지식 추출 (domain_knowledge.md)
        ↓
[1] 철학자 → 화두 도출 (도메인 지식 참조)
        ↓
[2-8] 기존 파이프라인과 동일
```

### 실행 방법
```bash
python run.py --input "소재.txt" --domain "references/journalism/" --interactive
```

### 도메인 자료 준비
`references/[도메인명]/` 디렉토리에 다음 유형의 자료를 준비:
- 해당 분야 입문서/개론서 (마크다운 변환)
- 내부자 인터뷰, 수기, 에세이
- 관련 사건/사례 기록
- 전문 용어집
- 업계 관행/윤리 강령

---

## 모드 B: 재작성 모드 (Revision Mode)

완성된 소설에 독자 피드백을 반영하여 수정합니다.

### 파이프라인

```
[기존 final.md] + [독자 피드백]
        ↓
[R1] 진단자 → 수정 계획 (revision_plan.md)
        ↓
[R2] 수정 범위에 따라 분기:
     ├─ 표면 수정 → 편집자 → 소설가 A
     ├─ 부분 수정 → 소설가 A
     ├─ 구조 재검토 → 소설가 B → 소설가 A
     └─ 근본 재검토 → 철학자부터 재실행
        ↓
[R3] 편집자 → 수정본 검토
        ↓
[R4] 소설가 A → 최종 반영 (revised_final.md)
```

### 실행 방법
```bash
python run.py --revise "workflow/outputs/08-final.md" --feedback "피드백 내용"
```

또는 피드백을 파일로:
```bash
python run.py --revise "workflow/outputs/08-final.md" --feedback-file "feedback.txt"
```

### 반복 재작성
재작성 결과가 여전히 불만족스러우면:
```bash
python run.py --revise "workflow/outputs/revised_final.md" --feedback "추가 피드백"
```

---

## 모드 조합

도메인 학습 + 재작성을 조합할 수 있습니다:

1. 도메인 학습 모드로 초안 완성
2. 검토 후 재작성 모드로 수정
3. 필요시 반복
```

---

## 작업 4: run.py 확장

기존 `workflow/run.py`의 **끝에** 다음 기능을 추가하세요.
(기존 코드는 수정하지 마세요)

### 추가할 메서드들

```python
# ============================================
# 확장 기능: 도메인 학습 및 재작성 모드
# ============================================

def load_domain_materials(self, domain_path: str) -> str:
    """도메인 디렉토리의 모든 마크다운 파일을 읽어 결합"""
    import os
    materials = []
    for filename in os.listdir(domain_path):
        if filename.endswith('.md'):
            filepath = os.path.join(domain_path, filename)
            with open(filepath, 'r', encoding='utf-8') as f:
                materials.append(f"## {filename}\n\n{f.read()}")
    return "\n\n---\n\n".join(materials)

def run_researcher(self, user_input: str, domain_path: str) -> str:
    """리서처 에이전트: 도메인 자료 분석"""
    domain_materials = self.load_domain_materials(domain_path)
    context = {
        "user_input": user_input,
        "domain_materials": domain_materials
    }
    result = self.run_agent("researcher", user_input, context)
    self.save_output("00-domain_knowledge.md", result)
    return result

def run_diagnostician(self, final_text: str, feedback: str) -> str:
    """진단자 에이전트: 피드백 분석 및 수정 계획"""
    context = {
        "original_text": final_text,
        "feedback": feedback
    }
    result = self.run_agent("diagnostician", feedback, context)
    self.save_output("R1-revision_plan.md", result)
    return result

def run_pipeline_with_domain(self, user_input: str, domain_path: str, checkpoints: bool = True):
    """도메인 학습 모드 파이프라인"""
    print("[도메인 학습 모드]")
    
    # Step 0: 리서처
    print("\n[Step 0] 리서처 에이전트 - 도메인 지식 추출")
    domain_knowledge = self.run_researcher(user_input, domain_path)
    
    # Step 1: 철학자 (도메인 지식 포함)
    print("\n[Step 1] 철학자 에이전트 - 화두 도출")
    enhanced_input = f"{user_input}\n\n## 도메인 지식\n{domain_knowledge}"
    theme = self.run_agent("philosopher", enhanced_input, {})
    self.save_output("01-theme.md", theme)
    
    # 이후 기존 파이프라인 계속...
    # (기존 run_pipeline의 Step 2 이후 로직 호출)

def run_revision(self, final_path: str, feedback: str):
    """재작성 모드 파이프라인"""
    print("[재작성 모드]")
    
    # 기존 완성본 로드
    with open(final_path, 'r', encoding='utf-8') as f:
        final_text = f.read()
    
    # Step R1: 진단자
    print("\n[Step R1] 진단자 에이전트 - 피드백 분석")
    revision_plan = self.run_diagnostician(final_text, feedback)
    
    # Step R2: 수정 범위에 따라 분기
    # (revision_plan 파싱하여 scope 판단)
    print("\n[Step R2] 수정 실행")
    
    # 간소화된 버전: 소설가 A가 수정 계획 반영
    context = {
        "original_text": final_text,
        "revision_plan": revision_plan
    }
    revised = self.run_agent("novelist-creator", final_text, context)
    self.save_output("R2-draft_revised.md", revised)
    
    # Step R3: 편집자 검토
    print("\n[Step R3] 편집자 에이전트 - 수정본 검토")
    edit_notes = self.run_agent("editor", revised, {})
    self.save_output("R3-edit_notes.md", edit_notes)
    
    # Step R4: 최종 반영
    print("\n[Step R4] 소설가 A - 최종 반영")
    context = {"edit_notes": edit_notes}
    revised_final = self.run_agent("novelist-creator", revised, context)
    self.save_output("revised_final.md", revised_final)
    
    print("\n[완료] revised_final.md 생성됨")
    return revised_final
```

### 메인 함수 확장 (argparse 부분)

```python
# 기존 argparse에 추가할 인자들
parser.add_argument('--domain', type=str, help='도메인 자료 디렉토리 경로')
parser.add_argument('--revise', type=str, help='재작성할 기존 완성본 경로')
parser.add_argument('--feedback', type=str, help='독자 피드백 (직접 입력)')
parser.add_argument('--feedback-file', type=str, help='독자 피드백 파일 경로')

# 메인 로직 분기
if args.revise:
    # 재작성 모드
    feedback = args.feedback
    if args.feedback_file:
        with open(args.feedback_file, 'r', encoding='utf-8') as f:
            feedback = f.read()
    workflow.run_revision(args.revise, feedback)
elif args.domain:
    # 도메인 학습 모드
    workflow.run_pipeline_with_domain(args.input, args.domain, args.interactive)
else:
    # 기본 모드
    workflow.run_pipeline(args.input, args.interactive)
```

---

## 작업 5: 디렉토리 구조 생성

다음 디렉토리를 생성하세요:

```bash
mkdir -p references/journalism
mkdir -p references/medicine
mkdir -p references/law
```

`references/README.md` 파일 생성:

```markdown
# 도메인 자료 저장소

각 하위 디렉토리에 해당 분야의 참고 자료를 마크다운 형식으로 저장합니다.

## 디렉토리 구조
- `journalism/` - 언론, 미디어 관련
- `medicine/` - 의료, 병원 관련
- `law/` - 법조, 사법 관련
- (필요에 따라 추가)

## 자료 유형 권장
1. 해당 분야 입문서/개론 (요약본)
2. 내부자 인터뷰, 수기, 에세이
3. 관련 사건/사례 기록
4. 전문 용어집
5. 업계 관행/윤리 강령

## 파일 형식
- 모든 파일은 `.md` (마크다운) 형식
- UTF-8 인코딩
- 파일명에 공백 대신 언더스코어(_) 사용
```

---

## 최종 확인

작업 완료 후 다음을 확인해주세요:

1. **새 파일 생성 확인**
   - [ ] `agents/00-researcher.md`
   - [ ] `agents/00-diagnostician.md`
   - [ ] `references/README.md`

2. **기존 파일 확장 확인**
   - [ ] `agents/00-orchestration.md` 끝에 확장 모드 섹션 추가됨
   - [ ] `workflow/run.py` 끝에 새 메서드들 추가됨

3. **기존 기능 보존 확인**
   - [ ] 기존 `python run.py --input "소재.txt"` 명령이 여전히 작동함

4. **새 기능 테스트**
   - [ ] `python run.py --help`에 새 옵션들이 표시됨

---

작업을 시작하기 전에 기존 `run.py`와 `00-orchestration.md`의 현재 상태를 먼저 확인해주세요.
```

---

이 프롬프트를 `3단계: 도메인 학습 및 재작성 기능 추가.md`로 저장하시고 Claude Code에서 실행하시면 됩니다. 기존 작업물은 그대로 유지되면서 새 기능만 추가됩니다.
